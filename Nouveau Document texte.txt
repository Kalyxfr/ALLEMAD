import discord
from discord import app_commands
from discord.ext import commands, tasks
import datetime
import asyncio
import logging
import whois

logging.basicConfig(level=logging.INFO)

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

bot = commands.Bot(command_prefix="/", intents=intents, help_command=None)

active_countdowns = {}
muted_users = {}

@bot.event
async def on_ready():
    await bot.wait_until_ready()
    await bot.tree.sync()
    print(f'{bot.user} est maintenant en ligne !')
    print(f'Le bot est pr√©sent sur {len(bot.guilds)} serveur(s)')
    countdown_updater.start()
    await bot.tree.sync()
    print("Slash commands synchronis√©es !")

@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error):
    if isinstance(error, commands.MissingPermissions):
        embed = discord.Embed(
            title="‚ùå Permission refus√©e",
            description="Vous n'avez pas les permissions requises pour utiliser cette commande.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
    elif isinstance(error, commands.MissingRequiredArgument):
        embed = discord.Embed(
            title="‚ùå Arguments manquants",
            description=f"Argument requis manquant : `{error.param}`",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
    else:
        embed = discord.Embed(
            title="‚ùå Erreur",
            description=f"Une erreur s'est produite : {str(error)}",
            color=0xFF0000
        )
        try:
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except:
            pass

@bot.tree.command(name="whois", description="Recherche les informations WHOIS d‚Äôun domaine.")
@app_commands.describe(domain="Nom de domaine (ex: example.com)")
async def whois_command(interaction: discord.Interaction, domain: str):
    await interaction.response.defer()
    try:
        print(f"üîé Requ√™te WHOIS pour : {domain}")
        
        loop = asyncio.get_event_loop()
        whois_data = await loop.run_in_executor(None, lambda: whois.whois(domain))
        
        if not whois_data or whois_data.domain_name is None:
            await interaction.followup.send(f"‚ùå Aucun r√©sultat pour `{domain}`.")
            return

        embed = discord.Embed(title=f"WHOIS : {domain}", color=discord.Color.blue())
        embed.add_field(name="Nom de domaine", value=str(whois_data.domain_name), inline=False)
        embed.add_field(name="Registrar", value=str(whois_data.registrar), inline=False)
        embed.add_field(name="Cr√©ation", value=str(whois_data.creation_date), inline=True)
        embed.add_field(name="Expiration", value=str(whois_data.expiration_date), inline=True)
        embed.add_field(name="Serveurs DNS", value=", ".join(whois_data.name_servers) if whois_data.name_servers else "Non disponibles", inline=False)
        embed.set_footer(text="Donn√©es fournies par python-whois")

        await interaction.followup.send(embed=embed)
        print("‚úÖ WHOIS envoy√© avec succ√®s.")

    except Exception as e:
        print(f"‚ùó Erreur WHOIS : {e}")
        await interaction.followup.send(f"‚ö†Ô∏è Erreur lors de la r√©cup√©ration des donn√©es : `{e}`")

# --- Kick ---
@bot.tree.command(name="kick", description="Expulse un membre du serveur")
@discord.app_commands.describe(member="Le membre √† expulser", reason="Raison du kick")
@discord.app_commands.checks.has_permissions(kick_members=True)
async def kick(interaction: discord.Interaction, member: discord.Member, reason: str = "Aucune raison fournie"):
    if member.top_role >= interaction.user.top_role:
        embed = discord.Embed(
            title="‚ùå Erreur d'autorisation",
            description="Tu ne peux pas expulser quelqu'un ayant un r√¥le √©gal ou sup√©rieur.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        embed = discord.Embed(
            title="üë¢ Membre expuls√© !",
            description=f"{member.mention} a √©t√© expuls√© du serveur !",
            color=0xFFA500,
            timestamp=datetime.datetime.utcnow()
        )
        embed.add_field(name="Raison", value=reason, inline=False)
        embed.add_field(name="Mod√©rateur", value=interaction.user.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        print(f"[KICK] {member} expuls√© par {interaction.user} - Raison: {reason}")
    except discord.Forbidden:
        embed = discord.Embed(
            title="‚ùå Erreur d'autorisation",
            description="Je n'ai pas la permission d'expulser ce membre.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

# --- Ban ---
@bot.tree.command(name="ban", description="Bannit un membre du serveur")
@discord.app_commands.describe(member="Le membre √† bannir", reason="Raison du ban")
@discord.app_commands.checks.has_permissions(ban_members=True)
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str = "Aucune raison fournie"):
    if member.top_role >= interaction.user.top_role:
        embed = discord.Embed(
            title="‚ùå Erreur de permission",
            description="Vous ne pouvez pas bannir quelqu'un ayant un r√¥le √©gal ou sup√©rieur au v√¥tre.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        embed = discord.Embed(
            title="üî® Membre banni",
            description=f"{member.mention} a √©t√© banni du serveur.",
            color=0xFF0000,
            timestamp=datetime.datetime.utcnow()
        )
        embed.add_field(name="Raison", value=reason, inline=False)
        embed.add_field(name="Mod√©rateur", value=interaction.user.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        print(f"[BAN] {member} banni par {interaction.user} - Raison: {reason}")
    except discord.Forbidden:
        embed = discord.Embed(
            title="‚ùå Erreur de permission",
            description="Je n'ai pas la permission de bannir ce membre.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

# --- Unban ---
@bot.tree.command(name="unban", description="D√©bannit un membre du serveur")
@discord.app_commands.describe(member="Nom complet du membre (exemple: Nom#1234)")
@discord.app_commands.checks.has_permissions(ban_members=True)
async def unban(interaction: discord.Interaction, member: str):
    try:
        member_name, member_discriminator = member.split('#')
    except ValueError:
        await interaction.response.send_message("‚ùå Le format doit √™tre `nom#1234`.", ephemeral=True)
        return
    banned_users = [entry async for entry in interaction.guild.bans()]
    for ban_entry in banned_users:
        user = ban_entry.user
        if (user.name, user.discriminator) == (member_name, member_discriminator):
            await interaction.guild.unban(user)
            embed = discord.Embed(
                title="‚úÖ Membre d√©banni",
                description=f"{user.mention} a √©t√© d√©banni.",
                color=0x00FF00,
                timestamp=datetime.datetime.utcnow()
            )
            embed.add_field(name="Mod√©rateur", value=interaction.user.mention, inline=True)
            await interaction.response.send_message(embed=embed)
            return
    embed = discord.Embed(
        title="‚ùå Utilisateur non trouv√©",
        description="L'utilisateur n'a pas √©t√© trouv√© dans la liste des bannis.",
        color=0xFF0000
    )
    await interaction.response.send_message(embed=embed, ephemeral=True)

# --- Mute ---
@bot.tree.command(name="mute", description="Rend un membre muet")
@discord.app_commands.describe(member="Le membre √† mute", duration="Dur√©e en minutes (optionnel)", reason="Raison du mute")
@discord.app_commands.checks.has_permissions(manage_roles=True)
async def mute(interaction: discord.Interaction, member: discord.Member, duration: int = None, reason: str = "Aucune raison fournie"):
    mute_role = discord.utils.get(interaction.guild.roles, name="Muted")
    
    if not mute_role:
        mute_role = await interaction.guild.create_role(name="Muted")
        for channel in interaction.guild.channels:
            await channel.set_permissions(mute_role, send_messages=False, speak=False)
    
    if mute_role in member.roles:
        embed = discord.Embed(
            title="‚ùå D√©j√† muet",
            description=f"{member.mention} est d√©j√† muet.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return
    
    await member.add_roles(mute_role, reason=reason)
    
    embed = discord.Embed(
        title="üîá Membre rendu muet",
        description=f"{member.mention} a √©t√© rendu muet.",
        color=0xFFA500,
        timestamp=datetime.datetime.utcnow()
    )
    embed.add_field(name="Raison", value=reason, inline=False)
    embed.add_field(name="Mod√©rateur", value=interaction.user.mention, inline=True)
    
    if duration:
        embed.add_field(name="Dur√©e", value=f"{duration} minutes", inline=True)
        muted_users[member.id] = {
            'guild_id': interaction.guild.id,
            'unmute_time': datetime.datetime.utcnow() + datetime.timedelta(minutes=duration)
        }
    
    await interaction.response.send_message(embed=embed)
    
    if duration:
        try:
            await asyncio.sleep(duration * 60)
            member_refetch = interaction.guild.get_member(member.id)
            if member_refetch and mute_role in member_refetch.roles and member.id in muted_users:
                await member_refetch.remove_roles(mute_role, reason="D√©mute automatique")
                muted_users.pop(member.id, None)
        except Exception as e:
            print(f"Erreur lors du d√©mute automatique de {member}: {e}")

# --- Unmute ---
@bot.tree.command(name="unmute", description="Enl√®ve le mute d'un membre")
@discord.app_commands.describe(member="Le membre √† unmute")
@discord.app_commands.checks.has_permissions(manage_roles=True)
async def unmute(interaction: discord.Interaction, member: discord.Member):
    mute_role = discord.utils.get(interaction.guild.roles, name="Muted")
    
    if not mute_role or mute_role not in member.roles:
        embed = discord.Embed(
            title="‚ùå Pas muet",
            description=f"{member.mention} n'est pas muet.",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return
    
    await member.remove_roles(mute_role)
    muted_users.pop(member.id, None)
    
    embed = discord.Embed(
        title="üîä Membre d√©muet",
        description=f"{member.mention} peut de nouveau parler.",
        color=0x00FF00,
        timestamp=datetime.datetime.utcnow()
    )
    embed.add_field(name="Mod√©rateur", value=interaction.user.mention, inline=True)
    await interaction.response.send_message(embed=embed)

# --- Clear messages ---
@bot.tree.command(name="clear", description="Supprime un nombre de messages dans le salon")
@discord.app_commands.describe(amount="Nombre de messages √† supprimer (minimum 1)")
@discord.app_commands.checks.has_permissions(manage_messages=True)
async def clear(interaction: discord.Interaction, amount: int = 5):
    if amount < 1:
        await interaction.response.send_message("‚ùå Le nombre de messages √† supprimer doit √™tre sup√©rieur √† 0.", ephemeral=True)
        return
    deleted = await interaction.channel.purge(limit=amount)
    await interaction.response.send_message(f"‚úÖ {len(deleted)} messages supprim√©s.", delete_after=5)

# --- Userinfo ---
@bot.tree.command(name="userinfo", description="Affiche les infos d'un membre")
@discord.app_commands.describe(member="Le membre (optionnel)")
async def userinfo(interaction: discord.Interaction, member: discord.Member = None):
    member = member or interaction.user
    roles = [role.mention for role in member.roles if role != interaction.guild.default_role]
    roles_str = ", ".join(roles) if roles else "Aucun r√¥le"
    
    joined = member.joined_at
    joined_str = joined.strftime("%d/%m/%Y %H:%M:%S") if joined else "Date d'entr√©e inconnue"
    
    embed = discord.Embed(title=f"Infos sur {member}", color=0x00FFFF)
    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
    embed.add_field(name="ID", value=member.id, inline=False)
    embed.add_field(name="Pseudo", value=member.display_name, inline=True)
    embed.add_field(name="Compte cr√©√© le", value=member.created_at.strftime("%d/%m/%Y %H:%M:%S"), inline=True)
    embed.add_field(name="Membre depuis le", value=joined_str, inline=True)
    embed.add_field(name=f"R√¥les ({len(roles)})", value=roles_str, inline=False)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="ping", description="Affiche la latence du bot")
async def ping(interaction: discord.Interaction):
    await interaction.response.send_message(f"Pong ! Latence : {round(bot.latency * 1000)}ms")

@bot.tree.command(name="help", description="Liste des commandes")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(
        title="Liste des commandes",
        description="Ce bot utilise uniquement des commandes slash.",
        color=0x00FFFF
    )
    embed.add_field(name="/kick <membre> [raison]", value="Expulse un membre du serveur.", inline=False)
    embed.add_field(name="/ban <membre> [raison]", value="Bannit un membre du serveur.", inline=False)
    embed.add_field(name="/unban <nom#1234>", value="D√©bannit un membre.", inline=False)
    embed.add_field(name="/mute <membre> [dur√©e] [raison]", value="Rend un membre muet.", inline=False)
    embed.add_field(name="/unmute <membre>", value="Enl√®ve le mute d'un membre.", inline=False)
    embed.add_field(name="/clear [nombre]", value="Supprime des messages dans le salon.", inline=False)
    embed.add_field(name="/userinfo [membre]", value="Affiche les infos d'un membre.", inline=False)
    embed.add_field(name="/ping", value="Affiche la latence du bot.", inline=False)
    embed.add_field(name="/whois", value="Affiche les informations sur un site web.", inline=False)
    await interaction.response.send_message(embed=embed)

@tasks.loop(seconds=10)
async def countdown_updater():
    now = datetime.datetime.utcnow()
    to_remove = []
    for channel_id, end_time in active_countdowns.items():
        if now >= end_time:
            channel = bot.get_channel(channel_id)
            if channel:
                await channel.send("‚è∞ Le d√©compte est termin√© !")
            to_remove.append(channel_id)
    for channel_id in to_remove:
        active_countdowns.pop(channel_id, None)

bot.run("MTM3MTUzMDk1NDU2NDQzNjA3OA.GbcbXV.LJHjMq_CUgPV1kPE99sAeKiSJf6afNFmeEAJIY")
